import { Dictionary } from "@reduxjs/toolkit";
import { NormalizedNode, getDefaultSkillValue } from "../../types";
import {
    getAllNodesFromLevel0ToLCALevelIncluded,
    getNodesInBetweenConflictingTrees,
    getTreesToShift,
    hierarchicalShiftNodes,
    treesToCenterAfterShift,
} from "./general";
import { countNodesPerLevel, getRadialTreeContourByLevel } from "../extractInformationFromTree";
import {
    getDistanceToCenterPerLevel,
    getNodesToShiftByOverlapRadial,
    getNodesToShiftForInternalOverlapRadial,
    getSubTreesDictionary,
} from "../treeToRadialCoordinates/overlap";
import { firstIteration } from "../treeToRadialCoordinates/firstInstance";
import { radiusPerLevelToAvoidLevelOvercrowd } from "../treeToRadialCoordinates/levelOvercrowd";
import { reverseNodeChildrenArray } from "../treeToRadialCoordinates/general";

const MOCK_SKILL_VALUE = getDefaultSkillValue("foo", false, { isEmoji: false, text: "foo" });

// const overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees: Dictionary<NormalizedNode> = {
//     "1": {
//         category: "SKILL",
//         childrenIds: ["a", "b", "c", "d"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 2,
//         nodeId: "1",
//         parentId: "goofyGoober",
//         treeId: "treeId",
//         x: 1.5921675970981117,
//         y: -1.210372811472079,
//     },
//     rootId: {
//         category: "SKILL_TREE",
//         childrenIds: ["goofyGoober", "sillyGoose", "tomfoolery"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: true,
//         level: 0,
//         nodeId: "rootId",
//         parentId: null,
//         treeId: "treeId",
//         x: 0,
//         y: 0,
//     },
//     goofyGoober: {
//         category: "SKILL",
//         childrenIds: ["1"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 1,
//         nodeId: "goofyGoober",
//         parentId: "rootId",
//         treeId: "treeId",
//         x: 0.7960837985490559,
//         y: -0.6051864057360395,
//     },
//     a: {
//         category: "SKILL",
//         childrenIds: ["a1"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 3,
//         nodeId: "a",
//         parentId: "1",
//         treeId: "treeId",
//         x: 1.6835041606480243,
//         y: -2.483105664501773,
//     },
//     a1: {
//         category: "SKILL",
//         childrenIds: ["a11", "a12", "a13", "a14", "a15"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 4,
//         nodeId: "a1",
//         parentId: "a",
//         treeId: "treeId",
//         x: 2.2446722141973656,
//         y: -3.3108075526690306,
//     },
//     a11: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "a11",
//         parentId: "a1",
//         treeId: "treeId",
//         x: 1.6476056239355894,
//         y: -4.720741012592812,
//     },
//     a12: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "a12",
//         parentId: "a1",
//         treeId: "treeId",
//         x: 2.2456721662618078,
//         y: -4.467320955749318,
//     },
//     a13: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "a13",
//         parentId: "a1",
//         treeId: "treeId",
//         x: 2.805840267746707,
//         y: -4.138509440836288,
//     },
//     a14: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "a14",
//         parentId: "a1",
//         treeId: "treeId",
//         x: 3.3186564124344575,
//         y: -3.7398555608749993,
//     },
//     a15: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "a15",
//         parentId: "a1",
//         treeId: "treeId",
//         x: 3.7754662060577635,
//         y: -3.2780870834857017,
//     },
//     b: {
//         category: "SKILL",
//         childrenIds: ["b1"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 3,
//         nodeId: "b",
//         parentId: "1",
//         treeId: "treeId",
//         x: 2.177949617704197,
//         y: -2.0631372864504534,
//     },
//     b1: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 4,
//         nodeId: "b1",
//         parentId: "b",
//         treeId: "treeId",
//         x: 2.9039328236055963,
//         y: -2.7508497152672713,
//     },
//     c: {
//         category: "SKILL_TREE",
//         childrenIds: ["c1"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 3,
//         nodeId: "c",
//         parentId: "1",
//         treeId: "treeId",
//         x: 2.5705517915379907,
//         y: -1.5466943741479193,
//     },
//     c1: {
//         category: "SKILL_TREE",
//         childrenIds: ["c11", "c12", "c13", "c14", "c15"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 4,
//         nodeId: "c1",
//         parentId: "c",
//         treeId: "treeId",
//         x: 3.4274023887173213,
//         y: -2.062259165530559,
//     },
//     c11: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "c11",
//         parentId: "c1",
//         treeId: "treeId",
//         x: 3.477550743839324,
//         y: -3.5925813594158957,
//     },
//     c12: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "c12",
//         parentId: "c1",
//         treeId: "treeId",
//         x: 3.913928005369967,
//         y: -3.11145746697278,
//     },
//     c13: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "c13",
//         parentId: "c1",
//         treeId: "treeId",
//         x: 4.284252985896652,
//         y: -2.577823956913199,
//     },
//     c14: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "c14",
//         parentId: "c1",
//         treeId: "treeId",
//         x: 4.582276002327871,
//         y: -2.0006865417876196,
//     },
//     c15: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 5,
//         nodeId: "c15",
//         parentId: "c1",
//         treeId: "treeId",
//         x: 4.802967554887453,
//         y: -1.389785115296046,
//     },
//     d: {
//         category: "SKILL_TREE",
//         childrenIds: ["d1"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 3,
//         nodeId: "d",
//         parentId: "1",
//         treeId: "treeId",
//         x: 2.842952179244447,
//         y: -0.9579263575710029,
//     },
//     d1: {
//         category: "SKILL_TREE",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 4,
//         nodeId: "d1",
//         parentId: "d",
//         treeId: "treeId",
//         x: 3.790602905659263,
//         y: -1.2772351434280038,
//     },
//     sillyGoose: {
//         category: "SKILL",
//         childrenIds: ["SGChild"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 1,
//         nodeId: "sillyGoose",
//         parentId: "rootId",
//         treeId: "treeId",
//         x: 1,
//         y: 0,
//     },
//     SGChild: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 2,
//         nodeId: "SGChild",
//         parentId: "sillyGoose",
//         treeId: "treeId",
//         x: 2,
//         y: 0,
//     },
//     tomfoolery: {
//         category: "SKILL",
//         childrenIds: ["TFChild"],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 1,
//         nodeId: "tomfoolery",
//         parentId: "rootId",
//         treeId: "treeId",
//         x: 0.7960837985490559,
//         y: 0.6051864057360395,
//     },
//     TFChild: {
//         category: "SKILL",
//         childrenIds: [],
//         data: MOCK_SKILL_VALUE,
//         isRoot: false,
//         level: 2,
//         nodeId: "TFChild",
//         parentId: "tomfoolery",
//         treeId: "treeId",
//         x: 1.5921675970981117,
//         y: 1.210372811472079,
//     },
// };
// console.log(
//     JSON.stringify(
//         getNodesToShiftForInternalOverlapRadial(overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees, "rootId", {
//             lastChildIdOfTree: "a15",
//             firstChildIdOfNextTree: "c11",
//         })
//     )
// );

// console.log(
//     JSON.stringify(
//         getNodesToShiftByOverlapRadial(overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees, "rootId", 1, [
//             "rootId",
//             "1",
//             "a",
//             "a1",
//             "a15",
//         ])
//     )
// );

const nodes: Dictionary<NormalizedNode> = {
    "21a": {
        category: "SKILL",
        childrenIds: [],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 2,
        nodeId: "21a",
        parentId: "1-1",
        treeId: "firstTree",
        x: -1,
        y: 2,
    },
    "21b": {
        category: "SKILL",
        childrenIds: [],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 2,
        nodeId: "21b",
        parentId: "1-1",
        treeId: "firstTree",
        x: 0,
        y: 2,
    },
    "1-1": {
        category: "SKILL",
        childrenIds: ["21a", "21b"],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 1,
        nodeId: "1-1",
        parentId: "rootId",
        treeId: "firstTree",
        x: -0.5,
        y: 1,
    },
    "22a": {
        category: "SKILL",
        childrenIds: [],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 2,
        nodeId: "22a",
        parentId: "1-2",
        treeId: "secondTree",
        x: 0,
        y: 2,
    },
    "22b": {
        category: "SKILL",
        childrenIds: [],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 2,
        nodeId: "22b",
        parentId: "1-2",
        treeId: "secondTree",
        x: 1,
        y: 2,
    },
    "1-2": {
        category: "SKILL",
        childrenIds: ["22a", "22b"],
        data: MOCK_SKILL_VALUE,
        isRoot: false,
        level: 1,
        nodeId: "1-2",
        parentId: "rootId",
        treeId: "secondTree",
        x: 0.5,
        y: 1,
    },
    rootId: {
        category: "SKILL_TREE",
        childrenIds: ["1-1", "1-2"],
        data: MOCK_SKILL_VALUE,
        isRoot: true,
        level: 0,
        nodeId: "rootId",
        parentId: null,
        treeId: "rootTree",
        x: 0,
        y: 0,
    },
};
// const tablita = radiusPerLevelToAvoidLevelOvercrowd(nodes);
console.log(JSON.stringify(reverseNodeChildrenArray(nodes)));

// const foo = firstIteration(overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees, "rootId", tablita);

// const keys = Object.keys(overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees);

// console.log(keys.map((nodeId) => overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees[nodeId]!.x));
// console.log(keys.map((nodeId) => overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees[nodeId]!.y));
// console.log(keys.map((nodeId) => `${nodeId} - (${overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees[nodeId]!.x},${overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees[nodeId]!.y})`));
// console.log(JSON.stringify(firstIteration(overlapCaseWithNodesInBetweenConflictingTreesAndNodesRightOfConflictingTrees, "rootId", tablita)));
